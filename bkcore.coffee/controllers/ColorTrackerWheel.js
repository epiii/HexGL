// Generated by CoffeeScript 1.7.1

/*
  ColorTrackerWheel (stick + buttons) for touch devices
  Based on the touch demo by Seb Lee-Delisle <http://seb.ly/>
  
  @class bkcore.controllers.ColorTrackerWheel
  @author Thibaut 'BKcore' Despoulain <http://bkcore.com>
 */

(function() {
  var ColorTrackerWheel, Vec2, exports, _base;

  ColorTrackerWheel = (function() {
    ColorTrackerWheel.isCompatible = function() {
      return true;
    };


    /*
      Creates a new ColorTrackerWheel
    
      @param dom DOMElement The element that will listen to touch events
      @param buttonCallback function Callback for non-stick touches
     */

    function ColorTrackerWheel(dom, buttonCallback) {
      this.setupTracker(dom);

      this.dom = dom;
      this.buttonCallback = buttonCallback != null ? buttonCallback : null;
      this.active = true;

      this.videoCenter = new Vec2(dom.offsetWidth/2, dom.offsetHeight/2);
    };

    /*
      @private
     */

    ColorTrackerWheel.prototype.colorFound = function(payload) {
      var maxRedArea = -1,
          maxRedRect,
          maxBlueArea = -1,
          maxBlueRect;

      if (!this.active) {
        return;
      }

      payload.forEach(function(rect) { 
        var area = rect.width * rect.height;

        if (rect.color == 'blue' && area > maxBlueArea) {
          maxBlueArea = area;
          maxBlueRect = rect;
        }
        else if (rect.color == 'red' && area > maxBlueArea) {
          maxRedArea = area;
          maxRedRect = rect;
        }
      });

      if (!maxRedRect || !maxBlueRect) {
        this.colorNotFound();
        return;
      }

      this.drawTrackingFeedback(maxRedRect, maxBlueRect);

      this.updateKeys(maxRedRect, maxBlueRect);
    };

    /*
      @private
     */

    ColorTrackerWheel.prototype.drawTrackingFeedback = function(maxRedRect, maxBlueRect) {
      var redCenter = new Vec2(maxRedRect.x + maxRedRect.width/2,
                               maxRedRect.y + maxRedRect.height/2),
          blueCenter = new Vec2(maxBlueRect.x + maxBlueRect.width/2,
                                maxBlueRect.y + maxBlueRect.height/2);

      var context = this.context;
      context.clearRect (0,0,320,240);

      context.strokeStyle = maxBlueRect.color;
      context.strokeRect(maxBlueRect.x, maxBlueRect.y, maxBlueRect.width, maxBlueRect.height);
      context.strokeStyle = maxRedRect.color;
      context.strokeRect(maxRedRect.x, maxRedRect.y, maxRedRect.width, maxRedRect.height);

      context.save();
      context.strokeStyle = 'yellow';
      context.beginPath();
      context.moveTo(redCenter.x, redCenter.y);
      context.lineTo(blueCenter.x, blueCenter.y);
      context.stroke();
      context.restore();
      // </DEBUG>
    };

    /*
      @private
     */

    ColorTrackerWheel.prototype.updateKeys = function(maxRedRect, maxBlueRect) {
      var redCenter = new Vec2(maxRedRect.x + maxRedRect.width/2,
                               maxRedRect.y + maxRedRect.height/2),
          blueCenter = new Vec2(maxBlueRect.x + maxBlueRect.width/2,
                                maxBlueRect.y + maxBlueRect.height/2),
          diff = new Vec2(maxBlueRect.x - maxRedRect.x, maxBlueRect.y - maxRedRect.y);
          left = 0,
          right = 0,
          delta = diff.x/diff.norm();

      if (delta > 0.1) {
        left = delta;
      }
      else if (delta < -0.1) {
        right = -delta;
      }

      this.buttonCallback({ left: left, right: right, forward: true });
    };


    /*
      @private
     */

    ColorTrackerWheel.prototype.colorNotFound = function() {
      if (!this.active) {
        return;
      }

      this.buttonCallback({ left: false, right: false, forward: false });
    };

    /*
      @private
     */

    ColorTrackerWheel.prototype.setupTracker = function(dom) {
      var tracker = new tracking.ColorTracker(),
          self = this;

      tracking.ColorTracker.registerColor('red', function(r,g,b) {
        if (!(r+g+b)) return false;

        var result = 100*r/(r+g+b) > 60 && r > 100;
        return result;
      });

      tracking.ColorTracker.registerColor('blue', function(r,g,b) {
        if (!(r+g+b)) return false;

        var result = 100*r/(r+g+b) < 30 && 100*g/(r+g+b) < 30 && b > 100;
        return result;
      });

      tracker.setColors(['red', 'blue']);

      tracker.on('track', function(event) {
        self.colorFound(event.data);
      });

      tracker.onNotFound = (function() { self.colorNotFound(); });

      this.tracker = tracker;

      var canvas = tracking.one('#trackingFeedbackCanvas');
      this.context = canvas.getContext('2d');

      tracking.track(dom, tracker, { camera: true });
    };


    return ColorTrackerWheel;

  })();


  /*
    Internal class used for vector2
    @class Vec2
    @private
   */

  Vec2 = (function() {
    function Vec2(x, y) {
      this.x = x != null ? x : 0;
      this.y = y != null ? y : 0;
    }

    Vec2.prototype.subtract = function(vec) {
      return new Vec2(this.x - vec.x, this.y, vec.y);
    };

    Vec2.prototype.norm = function() {
      return Math.sqrt(this.x*this.x + this.y*this.y);
    };

    return Vec2;

  })();


  /*
    Exports
    @package bkcore
   */

  exports = exports != null ? exports : this;

  exports.bkcore || (exports.bkcore = {});

  (_base = exports.bkcore).controllers || (_base.controllers = {});

  exports.bkcore.controllers.ColorTrackerWheel = ColorTrackerWheel;

}).call(this);
